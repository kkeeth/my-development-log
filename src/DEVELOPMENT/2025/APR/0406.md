# 0406

## LOGS

- typescript（ブルーベリー本の続き）
  - 思ったより基礎がなっていない
  - 用語
    - `型注釈（type annotation）`
      - `const age: number` ←の `number` のこと
    - `インデックスシグネチャ`
      - オブジェクトの型の中で使える特殊な記法
        - `[key: string]: 型` が基本の形
      - 「どんな名前のプロパティも受け入れる」という性質のオブジェクト型を記述できる
        - 例
        ```ts
        type PriceData = {
          [key: string]: number;
        }

        const data: PriceData = {
          apple: 220,
          coffee: 120,
          bento: 500,
        };
        ```
      - これは落とし穴がある機能で，型安全性が破壊されてしまう可能性がある
        - `noUncheckedIndexedAccess` コンパイラオプションを使えば危険性はなくなる
    - `部分型`
      - 型S，型T において，`S⊃T` で表せる型
      - ただし，呼び方としては「S は T の部分型」となる
      - TypeScript における部分型関係は `構造的部分型`
      - プログラミング言語の中では比較的珍しい特徴
      - よくあるオブジェクト指向プログラミングでは `名前的部分型`
  - オブジェクトは型注釈がなくても，型推論してくれる
    ```ts
    const obj = {
      foo: 123,
      bar: "Hello, World",
    };

    obj.foo = null; // Error: Type 'null' is not assignable to type 'number'.
    ```
  - type 文は新たに型を作って利用可能にする **のではなく**，**既存の型に別名をつけるだけ** のもの
  - **type 文は任意の型に対して別名を宣言できるが，interface 宣言はオブジェクト型のみ扱える**
    - ↑このことから，type 文のほうが広く使える場面が多いので，interface 宣言を使わず `type 文のみを使う` 派の人もいる
    - 俺もこうしようかな
    - 一応特殊なケースで，interface 宣言じゃないとできないことがある（`Declaration Merging`）
    - type 文が実装されない（2014年以前）は interface 宣言しかなかったので，今でもオブジェクトの型を作る際はこちらを利用する人や手癖になっている人もいるとか（ふーん）
  - お部署なるなプロパティを用いて演算処理はエラー
    - プリミティブな変数ならエラーにはならない
    - オブジェクトの場合，例えば `obj.baz` の型が `number | undefined` の場合，たとえプロパティに値がセットされていても `obj.baz * 10` はコンパイルエラー
  - 読み取り専用プロパティ（`readonly`）
    - そのプロパティは値の再代入ができない
    - こんな風に書く
      ```ts
      type MyObj = {
        readonly foo: number;
      }

      const obj: MyObj = { foo: 123 };

      obj.foo = 0;
      ```
  - `typeof キーワード` を用いて型をセットする
    - とある変数を型推論し，推論結果が型となる
    - 基本的には型が最上位にくる
      - 型が決まって，それに従って実装をしていく
      - 例えばプロパティが追加になった場合，まず型を変更しそれに依存した実装を変更していくから
      - 逆に実装の値が先に来る場合に， `typeof` を用いて型を抜き出して用いる
  -